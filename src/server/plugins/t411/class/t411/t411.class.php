<?php    namespace t411;    	class T411 {		private static $_instance;		private static $host = 'http://api.t411.me';		private static $expire_token = 90; # in days		private $username;		private $token;		private $torlimit = 10;        private $orderby = 'seeders';        private $ordertype = 'desc';        		public static function i() {			if (empty(self::$_instance))				self::$_instance = new T411();                			return self::$_instance;		}		        		private function __construct() {			$this->token = @$_COOKIE["t411_token"];		}				public function logout() {			$this->token = null;			setcookie("t411_token", @$_COOKIE["t411_token"], time() - 3600, "/");			unset($_COOKIE["t411_token"]);		}		public function auth($username, $password) {			$this->username = $username;			$response = http_request(self::$host.'/auth', 'POST', null, array(				'username' => $username,				'password' => $password			));						if (empty($response)) {			    return false;			}			$json = json_decode($response);						if ($json === null || property_exists($json, 'error')) {		        $this->logout();				return false;			}			setcookie("t411_token", $json->token, time() + 60 * 60 * 24 * self::$expire_token, "/");			$this->token = $json->token;            return true;		}		public function connected() {			if (empty($this->token))				return false;							if ($this->verified())			    return true;			$p = $this->profile();			if ($p === false || property_exists($p, 'error'))				return false;							$this->verify();							return true;		}				private function verify() {		    $_SESSION['user'.$this->id().'verify'] = true;		} 				public function verified() {		    return !empty($_SESSION['user'.$this->id().'verify']);		}		public function id() {			return current(explode(":", $this->token));		}		public function profile($refresh=false) {			if (empty($_SESSION['profil'.$this->id()]) || $refresh)				$_SESSION['profil'.$this->id()] = $this->request('/users/profile/'.$this->id());						return $_SESSION['profil'.$this->id()];		}				public function ratio() {			$p = $this->profile(true);						if ($p) return round($p->uploaded / $p->downloaded, 5);			return $p;		}		public function search($text, $p=1) {			$results = $this->request('/torrents/search/'. $text .'?offset='. ($p-1) * $this->torlimit .'&limit='. $this->torlimit .'&order='. $this->orderby . '&type='. $this->ordertype);            if (!is_object($results) && stripos($results, '}') !== false) {                $results = json_decode('{'.end(explode('{', $results, 2)));            }                        if (empty($results->torrents))            	return;            $this->sort($results->torrents);			$results->page = $p;			$results->pages = ceil($results->total / $this->torlimit);			return $results;		}                private function sort(&$torrents) {        	if (empty($torrents))        		return;        	            $c = $this->ordertype == 'asc' ? 1 : -1;                        usort($torrents, function($a, $b) use ($c) {                  $a = $a->{$this->orderby};                $b = $b->{$this->orderby};                                if (is_numeric($a))                    return (intval($a)-intval($b))*$c;                                    return strcmp($a,$b)*$c;            });        }        		public function top($category, $p=1) {			$torrents = $this->request('/torrents/top/'. $category);                        $results = new \stdClass();			$results->torrents = $torrents;            $this->sort($results->torrents);			$results->page = $p;			$results->pages = ceil(count($torrents) / count($torrents));            			return $results;		}        		public function limit($torlimit=null) {			if (func_num_args() == 0) return $this->torlimit;			$this->torlimit = $torlimit;                        return $this;		}                public function orderby($field, $type='asc') {            $this->orderby = $field;                        $this->ordertype = $type;                        return $this;             }                public function orderfield() { return $this->orderby; }        public function ordertype() { return $this->ordertype; }        		public function download($id, $to=null) {            $torrent = $this->request('/torrents/download/'. $id, null, null, 'plain');            $name = $id . '.torrent';                        if ($to == null) {                header('Content-Type: text/plain');                header('Content-Disposition: attachment; filename="' . $name . '"');                header('Content-Transfer-Encoding: binary');                header('Accept-Ranges: bytes');                echo $torrent;                exit;            }                        if (!is_dir($to)) return 'NO_DIR : '. $to;            if (!is_writable($to)) return 'NO_WRITABLE : '. $to;                        return file_put_contents($to.'/'.$name, $torrent) !== false;		}                private $_requests = [];		private $_last_error = null;				public function getLastError() {			return $this->_last_error;		}        		private function request($action, $method=null, $data=null, $dataType = 'json') {			$this->_last_error = null;					$response = http_request(self::$host.$action, $method, 'Authorization: '. $this->token, $data);			$this->_requests[] = ['action' => $action, 'response' => $response];                        if ($response === false)				return false;                			if ($dataType == 'json') {				$json = json_decode($response);								/*				 * Error : No JSON				 */				if (empty($json)) { 					$this->_last_error = 'Format de réponse du serveur erronée : '. $response;					//throw new T411Exception('Format de réponse du serveur erronée : '. $response, T411Exception::RESPONSE_ERROR_FORMAT);					return null;				}								return $json;			}							return $reponse;		}				public function requests() {			return $this->_requests;		}	}